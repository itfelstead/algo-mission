<!--
	algo-mission.html

	Initial version of the algo-mission project entry point.

	Author: Ian Felstead
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Algo-Mission</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
			/* Main Window */
			#AlgoMission {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}
		</style>
	</head>

	<body>
		<div id="AlgoMission"></div>

		<script src="thirdparty/threejs/three.min.js"></script>
		<script src="thirdparty/threejs/orbitcontrols.js"></script>

		<script>

			// ---------------

			const VERSION = 0.01;

			var g_MouseControls;

			var g_TextureLoader;

			var g_JSONLoader;

			// Texture taken from Optikz 2004 post on blenderartists,org
			var SKY_TEXTURE = "textures/sky_twilight.jpg";

			// Main Screen Globals
			var g_Scene;
			var g_Camera;
			var g_Renderer;
			var g_Element;
			var g_Container;

			// Bot
			var g_Bot;
			var g_BotMove = 0; 		// Amount to move in particular update
			var g_BotRotation = 0; 		// Amount to rotate in partucular update
			var BOT_TEXTURE = "textures/Toon_Bus_Texture.jpg";
			var BOT_MODEL = "models/ToonBus_VijayKumar.json";

			// Collision Detection
			var g_Raycaster;


			// Game Loop Globals
			const UPDATE_TIME_STEP = 0.033; // 33ms = approx 30 FPS
			var g_Clock;
			var g_Lag = 0; 	// used in game loop for fixed step update

			// Inset Command Window Globals
			var INSET_DIV_NAME = "CommandInset";
			var INSET_CANVAS_WIDTH = 200;
			var INSET_CANVAS_HEIGHT = 200;
			var INSET_LEFT_OFFSET = 0;
			var INSET_BOTTOM_OFFSET = 10;
			var INSET_MARGIN = 20;
			var INSET_CAM_FOV =30 
			var INSET_CAM_NEAR = 1;
			var INSET_CAM_FAR = 1000;
			var g_InsetEnabled  = 1;
			var g_InsetScene;
			var g_InsetRenderer;
			var g_InsetElement;
			var g_InsetContainer;
			var g_InsetCamera;

			// Control Panel
			var g_ControlPanelObjects; 	// an array of buttons (meshes)

			// Instructions
			var g_InstructionConfig = {
			   FORWARD: 1,
			   BACK: 2,
			   LEFT: 3,
			   RIGHT: 4,
			   GO: 5,
			   FIRE: 6,
			   PAUSE: 7,
			   CLEAR: 8,

			   properties: {
				1: {displayString: "forward<p>", value: 1},
				2: {displayString: "back<p>", value: 2},
			       	3: {displayString: "left<p>", value: 3},
			       	4: {displayString: "right<p>", value: 4},               
			       	5: {displayString: "go<p>", value: 5},
			       	6: {displayString: "fire!<p>", value: 6},
			       	7: {displayString: "pause..<p>", value: 7},
			       	8: {displayString: "", value: 8}
			   }
			};

			var g_Instructions = [];
			var g_InstructionHtml = "<b>Instructions:<b><p>";

			// Instruction operation processing
			var NO_INSTRUCTION = -1;
			var ROTATE_STEP = 90 * Math.PI/180; 	// Turn by 90 degrees (in radians)
			var MOVE_STEP = 10; 			// Move by 10 units
			var OP_TIME_STEP = 2; 			// Take 2 secs per instruction
			var OP_DELAY = 0.5; 			// half second delay between operations

			var g_OpTimer = 0; 			// How log operation has run for
			var g_CurrentInstructionIdx = NO_INSTRUCTION; 	// index into g_Instructions
			var g_InterInstructionPause = 0;
			


			// Main

			console.log( "algo-mission v" + VERSION + " starting..." );

			initialise();

			gameLoop(); 	// intial kickoff, subsequest calls via requestAnimationFrame()

			console.log( "...algo-mission complete." );

			// ---------------


			//
			// Initialisation
			//

			function initialise()
			{
				setupBasicScene();

				addInstructionWindow();

				addCamera();

				addSky();

				addAmbientLight();

				addMouseControls();
				
				addInsetWindow();

				addControlPanel( g_InsetScene );
				
				addAxisHelper();

				addBot();

				setupGameLoop();

				setupCollisionDetection();

				addEventListeners();
			}

			function setupGameLoop()
			{
				g_Clock = new THREE.Clock();

				g_Lag = 0;
			}

			function setupBasicScene()
			{
				g_Renderer = new THREE.WebGLRenderer();
				g_Element = g_Renderer.domElement;
				g_Container = document.getElementById('AlgoMission');
				g_Container.appendChild(g_Element);

				g_TextureLoader = new THREE.TextureLoader();

				g_JSONLoader = new THREE.JSONLoader();

				g_Scene = new THREE.Scene();
			}

			function addCamera()
			{
				g_Camera = new THREE.PerspectiveCamera(90, 1, 0.001, 1700);
				// look over bots shoulder
        			g_Camera.position.set(0, 20, -50);
	        		g_Camera.lookAt( new THREE.Vector3(0,0,0) );
		        	g_Scene.add(g_Camera);
			}

			function addMouseControls()
			{
        			g_MouseControls = new THREE.OrbitControls(g_Camera, g_Element);
        			// g_MouseControls.rotateUp(Math.PI / 4);

                                // Rotate about the center. 
	        		g_MouseControls.target.set( 0, 0, 0 );

				// Future note: If you wanted a VR like rotation then change
				// to rotate about camera position (plus a small offset) instead
				// and turn off pan/zoom. e.g.
				//g_MouseControls.target.set( g_Camera.position.x+0.1, g_Camera.position.y, g_Camera.position.z );
				//g_MouseControls.noZoom = true;
				//g_MouseControls.noPan = true;
			}

			function addAmbientLight()
			{
				var white = 0xA0A0A0;
				g_Scene.add( new THREE.AmbientLight(white) );

			}

			function addSky()
			{
				var skyGeo = new THREE.SphereGeometry( 500, 60, 40 );
				skyGeo.scale( - 1, 1, 1 );

				g_TextureLoader.load( SKY_TEXTURE,

					// on load
					function( texture )
					{
						var material = new THREE.MeshBasicMaterial( { map: texture } );
						var mesh = new THREE.Mesh( skyGeo, material );
						g_Scene.add( mesh );
					},
					// on download progress
					function( xhr )
					{
						console.log( SKY_TEXTURE + " " + (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// on error
					function( xhr )
					{
						console.log( 'Error loading sky texture ' + SKY_TEXTURE );
					}
				);

			}

			function addBot()
			{
				// var geo = new THREE.CubeGeometry( 10, 10, 10 );
				// var material = new THREE.MeshNormalMaterial();
				// g_Bot = new THREE.Mesh( geo, material );
				// g_Scene.add( g_Bot );

				g_TextureLoader.load( BOT_TEXTURE,

					// on load
					function( texture )
					{
						loadBotModel( texture );
					},
					// on download progress
					function( xhr )
					{
						console.log( BOT_TEXTURE + " " + (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// on error
					function( xhr )
					{
						console.log( 'Error loading bot texture ' + BOT_TEXTURE );
					}
				);
			}

			function loadBotModel( texture )
			{
				g_JSONLoader.load( BOT_MODEL,

					function( geometry )
					{
						var material = new THREE.MeshLambertMaterial( { map: texture } );
						geometry.scale(  100, 100, 100 );
						g_Bot = new THREE.Mesh( geometry, material );
						g_Scene.add( g_Bot );
					}
				);
			}

			function addEventListeners()
			{
				window.addEventListener('resize', handleResize, false);
				setTimeout(handleResize, 1);
			}
			
			function addInsetWindow()
			{
				if( !g_InsetEnabled )
				{
					return;
				}
				// Inset Window
				var insetDiv = document.createElement( "div" );
				insetDiv.id = INSET_DIV_NAME;
				insetDiv.style.cssText ="width: " + INSET_CANVAS_WIDTH + "px; " +
							"height: " + INSET_CANVAS_HEIGHT + "px; " +
							"left: " + INSET_LEFT_OFFSET + "px; " +
							"bottom: " + INSET_BOTTOM_OFFSET + "px;" +
							"background-color: transparent;" + /* or #fff */
							"opacity: 1; " + /* affects whole window */
							"border: none; " + /* or e.g. '2px solid black' */
							"margin: " + INSET_MARGIN + "px; " +
							"padding: 0px; " +
							"position: absolute; z-index: 100;";
				document.body.appendChild( insetDiv );
				g_InsetContainer = document.getElementById( INSET_DIV_NAME );
				// use 'alpha' to allow transparent inset window
				g_InsetRenderer = new THREE.WebGLRenderer( { alpha: true } );
				g_InsetRenderer.setSize( INSET_CANVAS_WIDTH, INSET_CANVAS_HEIGHT );
				g_InsetContainer.appendChild( g_InsetRenderer.domElement );
				g_InsetScene = new THREE.Scene();
				g_InsetCamera = new THREE.PerspectiveCamera( INSET_CAM_FOV, 
										INSET_CANVAS_WIDTH / INSET_CANVAS_HEIGHT, 
										INSET_CAM_NEAR, 
										INSET_CAM_FAR );
				g_InsetCamera.up = g_Camera.up;
        			g_InsetCamera.position.set(0, 0, -50);
			}

			function addControlPanel( sceneToUpdate )
			{
				g_ControlPanelObjects = {};

				// Layout is something like this (x grows left, y grows up)
				//
				//                 [forward]
				//           [left] [pause] [right]
				//    [fire]        [back]
				//           [clear]        [go]
				//
				var boxSize = 1; 	// for display size is irrelevant as FoV will alter to fill window
				var gridSize = 4; 	// panel buttons are placed on a 4x4 grid
				var defaultZ = 1;
				var stepSize = boxSize * 1.25;
				var offset = (-(gridSize * stepSize) / 2) + (boxSize/2);

				var panelConfig = [
					{ "id": g_InstructionConfig.FORWARD,    "x": 1, "y": 3, "z": defaultZ, "pic": "Up256.png" },
					{ "id": g_InstructionConfig.BACK,  "x": 1, "y": 1, "z": defaultZ, "pic": "Back256.png" },
					{ "id": g_InstructionConfig.LEFT,  "x": 2, "y": 2, "z": defaultZ, "pic": "Left256.png" },
					{ "id": g_InstructionConfig.RIGHT, "x": 0, "y": 2, "z": defaultZ, "pic": "Right256.png" },
					{ "id": g_InstructionConfig.CLEAR, "x": 2, "y": 0, "z": defaultZ, "pic": "Clear256.png" },
					{ "id": g_InstructionConfig.GO,    "x": 0, "y": 0, "z": defaultZ, "pic": "Go256.png" },
					{ "id": g_InstructionConfig.FIRE,  "x": 3, "y": 1, "z": defaultZ, "pic": "Fire256.png" },
					{ "id": g_InstructionConfig.PAUSE, "x": 1, "y": 2, "z": defaultZ, "pic": "Stop256.png" }
				];

				
				for (var i = 0; i < panelConfig.length; i++) 
				{
					var buttonConfig = panelConfig[i];
					var picture = buttonConfig.pic;
					var texture = g_TextureLoader.load( "textures/" + picture );

					var buttonGeo = new THREE.BoxGeometry( boxSize, boxSize, 0.1 );
					var buttonMaterial = new THREE.MeshBasicMaterial( {map: texture } );
					var buttonMesh = new THREE.Mesh( buttonGeo, buttonMaterial );

					buttonMesh.position.set( offset + (buttonConfig.x*stepSize), offset + (buttonConfig.y*stepSize), buttonConfig.z );

					buttonMesh.name = buttonConfig.id;

					g_ControlPanelObjects[ buttonConfig.id ] = buttonMesh;

					sceneToUpdate.add( buttonMesh );
				}

				// Adjust the FoV to fill the whole view with the control panel
				var dist = (-g_InsetCamera.position.z) + defaultZ;
				var height = gridSize * stepSize;
				var fov = 2 * Math.atan( height / ( 2 * dist ) ) * ( 180 / Math.PI );
				g_InsetCamera.fov = fov;
				g_InsetCamera.updateProjectionMatrix();

			}

			function addInstructionWindow() 
			{
				var instructionDiv = document.createElement('div');

				instructionDiv.id = "instructionTextBox";
				instructionDiv.style.cssText =
				            		"width: 200px;" +
							"height: 200px;" +
							"left: 20px;" +
							"top: 20px;" +
							"max-height: 200px;" +
							"min-height: 200px;" +
							"border: none;" +  /* or e.g. '2px solid black' */
							"background-color: DimGray;" +
							"color: White;" +
							// we want a 50% transparent background, but not 
							// transparent text, so use rgba rather than opacity.
							"background: rgba(105, 105, 105, 0.5);" +
							"overflow: auto;" +
							"position: absolute;" +
							"font: 12px arial,serif;";
				
				document.body.appendChild(instructionDiv);
			}

			function generateInstructionHtml()
			{

				var html = "<b>Instructions<b><p>";
				
				var numInstructions = g_Instructions.length;
				for( var i = 0; i < numInstructions; i++ )
				{
					if( i == g_CurrentInstructionIdx )
					{
						 html += "<b>";
					}

					var operEnum = g_Instructions[i];

					html += g_InstructionConfig.properties[ operEnum ].displayString;

					if( i == g_CurrentInstructionIdx )
					{
						 html += "</b>";
					}
				}

				return html;
			}

			function tailScroll()
			{
				document.getElementById("instructionTextBox").scrollTop = 
						document.getElementById("instructionTextBox").scrollHeight;
			}

			function setupCollisionDetection()
			{
				g_Raycaster = new THREE.Raycaster();

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			}

			//
			// Game Loop
			//

			// gameLoop()
			// Standard game loop with a fixed update rate to keep
			// things consistent, and a variable render rate to allow
			// for differences in machine performance
			//
			function gameLoop()
			{
				var elapsedTime = g_Clock.getDelta();

				g_Lag += elapsedTime;

				// perform as many updates as we should do
				// based on the time elapsed from last gameloop call
				while( g_Lag >= UPDATE_TIME_STEP )
				{
					update();

					g_Lag -= UPDATE_TIME_STEP;
				}

				render();

				requestAnimationFrame(gameLoop);
			}

			function update()
			{

				// Note: The time elapsed is UPDATE_TIME_STEP as we update in fixed steps

				processInstruction( UPDATE_TIME_STEP );

				if( g_InsetEnabled )
				{
					g_InsetCamera.lookAt( g_InsetScene.position );
				}

				if( typeof(g_Bot) != "undefined" )
				{
					g_Bot.rotation.set( 0, g_BotRotation, 0.0, 'XYZ' );
					
					if( g_BotMove != 0 )
					{
						g_Bot.translateX( g_BotMove );

						g_BotMove = 0; 		// we moved, so reset

			        		g_Camera.updateProjectionMatrix();
						g_Camera.lookAt( g_Bot.position );
					}
				}


			}

			function render( )
			{
				g_Renderer.render(g_Scene, g_Camera);
				if( g_InsetEnabled )
				{
					g_InsetRenderer.render(g_InsetScene, g_InsetCamera);
				}
			}

			function handleResize()
			{
				var width = g_Container.offsetWidth;
				var height = g_Container.offsetHeight;

				g_Camera.aspect = width / height;
			        g_Camera.updateProjectionMatrix();

				g_Renderer.setSize(width, height);
			}

			// Detect object clicks
			function onDocumentTouchStart( event )
			{
				event.preventDefault();
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );
			}

			function onDocumentMouseDown( event )
			{
				event.preventDefault();

				var mainElement = document.getElementById("AlgoMission");
				var mainWindowHeight = mainElement.clientHeight;

				// The event's X & Y are in relation to the main window
				// so we adjust them to be in relation to the inset window
				var insetClientX = event.clientX - (INSET_LEFT_OFFSET + INSET_MARGIN);
				var insetClientY = event.clientY - (mainWindowHeight - INSET_CANVAS_HEIGHT - (INSET_BOTTOM_OFFSET + INSET_MARGIN));

				// Normalise the X & Y and test for intersection with inset window objects
				var mouse = new THREE.Vector2();
 				mouse.x = ( insetClientX / g_InsetRenderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( insetClientY / g_InsetRenderer.domElement.clientHeight ) * 2 + 1;

				g_Raycaster.setFromCamera( mouse, g_InsetCamera );

				var buttonObjects = [];
				for( var key in g_ControlPanelObjects )
				{
				    var mesh = g_ControlPanelObjects[ key ];
				    
				    buttonObjects.push( mesh );
				}

				var instructionsUpdated = 0;

				var buttonIntersects = g_Raycaster.intersectObjects( buttonObjects );

				if( buttonIntersects.length > 0 )
				{
					// Intersection detected
					var objectClicked = buttonIntersects[ 0 ].object.name;
					console.log( "object " + buttonIntersects[ 0 ].object.name + " clicked");

					var instructionObjectClicked = buttonIntersects[ 0 ].object.name;
					if( instructionObjectClicked == g_InstructionConfig.CLEAR )
					{
						g_CurrentInstructionIdx = NO_INSTRUCTION;
						g_Instructions = [];
						instructionsUpdated = 1;
					}
					else if( instructionObjectClicked == g_InstructionConfig.GO )
					{
						g_OpTimer = OP_TIME_STEP;
						g_CurrentInstructionIdx = 0; 		// point to 1st instruction
					}
					else
					{
						g_Instructions.push( objectClicked );
						instructionsUpdated = 1;
					}
				}

				document.getElementById("instructionTextBox").innerHTML = generateInstructionHtml();
				tailScroll();
			}

			function processInstruction( deltaTime )
			{
				if( g_CurrentInstructionIdx == NO_INSTRUCTION )
				{
					// not yet running instructions
					return;
				}

				if( g_InterInstructionPause > 0 )
				{
					g_InterInstructionPause -= deltaTime;
					return;
				}
		
				g_OpTimer = g_OpTimer - deltaTime;

				var movementTime = deltaTime;
				if( g_OpTimer < 0 )
				{
					// reduce movement time by amount of overrun
					movementTime = deltaTime + g_OpTimer;
				}
				
				var rotationThisFrame = movementTime * (ROTATE_STEP / OP_TIME_STEP);
				var movementThisFrame = movementTime * (MOVE_STEP / OP_TIME_STEP);

				var currentOp = g_Instructions[ g_CurrentInstructionIdx ];

				g_BotMove
				if( currentOp == g_InstructionConfig.FORWARD )
				{
					g_BotMove = movementThisFrame;
				}
				else if( currentOp == g_InstructionConfig.BACK )
				{
					g_BotMove = -movementThisFrame;
				}
				else if( currentOp == g_InstructionConfig.LEFT )
				{
					g_BotRotation += rotationThisFrame;
				}
				else if( currentOp == g_InstructionConfig.RIGHT )
				{
					g_BotRotation -= rotationThisFrame;
				}

				// move to next instruction if time is up
				if( g_OpTimer <= 0 )
				{
					g_CurrentInstructionIdx++;
					g_OpTimer = OP_TIME_STEP;

					g_InterInstructionPause = OP_DELAY;

					if( g_CurrentInstructionIdx >= g_Instructions.length )
					{
						g_CurrentInstructionIdx = NO_INSTRUCTION;
						g_OpTimer = 0;
					}
				}
			}

			//
			// Debugging Functions
			//

			function addAxisHelper()
			{
				g_Scene.add( new THREE.AxisHelper( 50 ) );
			}
		</script>
	</body>
</html>
