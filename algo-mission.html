<!--
	algo-mission.html

	Initial version of the algo-mission project entry point.

	Author: Ian Felstead
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Algo-Mission</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
			/* Main Window */
			#AlgoMission {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}
		</style>
	</head>

	<body>
		<div id="AlgoMission"></div>

		<script src="thirdparty/threejs/three.min.js"></script>
		<script src="thirdparty/threejs/orbitcontrols.js"></script>

		<script>

			// ---------------

			const VERSION = 0.01;

			var g_MouseControls;

			// Main Screen Globals
			var g_Scene;
			var g_Camera;
			var g_Renderer;
			var g_Element;
			var g_Container;
			
			var g_Bot;

			// Collision Detection
			var g_Raycaster;


			// Game Loop Globals
			const UPDATE_TIME_STEP = 0.033; // 33ms = approx 30 FPS
			var g_Clock;
			var g_Lag = 0; 	// used in game loop for fixed step update

			// Inset Command Window Globals
			var INSET_DIV_NAME = "CommandInset";
			var INSET_CANVAS_WIDTH = 200;
			var INSET_CANVAS_HEIGHT = 200;
			var INSET_LEFT_OFFSET = 10;
			var INSET_BOTTOM_OFFSET = 10;
			var INSET_MARGIN = 20;
			var INSET_COLOUR = 0x4FABC9
			var INSET_CAM_FOV =30 
			var INSET_CAM_NEAR = 1;
			var INSET_CAM_FAR = 1000;
			var g_InsetEnabled  = 1;
			var g_InsetScene;
			var g_InsetRenderer;
			var g_InsetElement;
			var g_InsetContainer;
			var g_InsetCamera;

			// TBD: dummy object to confirm I can process clicks ok in inset window
			var g_ControlPanelObjectTest;


			// Main

			console.log( "algo-mission v" + VERSION + " starting..." );

			initialise();

			gameLoop(); 	// intial kickoff, subsequest calls via requestAnimationFrame()

			console.log( "...algo-mission complete." );

			// ---------------


			//
			// Initialisation
			//

			function initialise()
			{
				setupBasicScene();

				addCamera();

				addAmbientLight();

				addMouseControls();
				
				addInsetWindow();
				
				addAxisHelper();

				addBot();

				setupGameLoop();

				setupCollisionDetection();

				addEventListeners();
			}

			function setupGameLoop()
			{
				g_Clock = new THREE.Clock();

				g_Lag = 0;
			}

			function setupBasicScene()
			{
				g_Renderer = new THREE.WebGLRenderer();
				g_Element = g_Renderer.domElement;
				g_Container = document.getElementById('AlgoMission');
				g_Container.appendChild(g_Element);

				g_Scene = new THREE.Scene();
			}

			function addCamera()
			{
				g_Camera = new THREE.PerspectiveCamera(90, 1, 0.001, 1700);
				// look over bots shoulder
        			g_Camera.position.set(0, 20, -50);
	        		g_Camera.lookAt( new THREE.Vector3(0,0,0) );
		        	g_Scene.add(g_Camera);
			}

			function addMouseControls()
			{
        			g_MouseControls = new THREE.OrbitControls(g_Camera, g_Element);
        			// g_MouseControls.rotateUp(Math.PI / 4);

                                // Rotate about the center. 
	        		g_MouseControls.target.set( 0, 0, 0 );

				// Future note: If you wanted a VR like rotation then change
				// to rotate about camera position (plus a small offset) instead
				// and turn off pan/zoom. e.g.
				//g_MouseControls.target.set( g_Camera.position.x+0.1, g_Camera.position.y, g_Camera.position.z );
				//g_MouseControls.noZoom = true;
				//g_MouseControls.noPan = true;
			}

			function addAmbientLight()
			{
				var white = 0xA0A0A0;
				g_Scene.add( new THREE.AmbientLight(white) );

			}

			function addBot()
			{
				var geo = new THREE.CubeGeometry( 10, 10, 10 );
				var material = new THREE.MeshNormalMaterial();
				g_Bot = new THREE.Mesh( geo, material );

				//g_Bot.position.y = -100;
				//g_Bot.position.set( 2, 2, 2 );

				g_Scene.add( g_Bot );
			}

			function addEventListeners()
			{
				window.addEventListener('resize', handleResize, false);
				setTimeout(handleResize, 1);
			}
			
			function addInsetWindow()
			{
				if( !g_InsetEnabled )
				{
					return;
				}
				// Inset Window
				var insetDiv = document.createElement( "div" );
				insetDiv.id = INSET_DIV_NAME;
				insetDiv.style.cssText ="width: " + INSET_CANVAS_WIDTH + "px; " +
							"height: " + INSET_CANVAS_HEIGHT + "px; " +
							"left: " + INSET_LEFT_OFFSET + "px; " +
							"bottom: " + INSET_BOTTOM_OFFSET + "px;" +
							"background-color: #fff;" + /* or 'transparent;' */
							"opacity: 0.5; " + /* affects whole window */
							"border: none; " + /* or e.g. '2px solid black' */
							"margin: " + INSET_MARGIN + "px; " +
							"padding: 0px; " +
							"position: absolute; z-index: 100;";
				document.body.appendChild( insetDiv );
				g_InsetContainer = document.getElementById( INSET_DIV_NAME );
				// use 'alpha' to allow transparent inset window
				g_InsetRenderer = new THREE.WebGLRenderer( { alpha: true } );
				g_InsetRenderer.setClearColor( INSET_COLOUR , 1);
				g_InsetRenderer.setSize( INSET_CANVAS_WIDTH, INSET_CANVAS_HEIGHT );
				g_InsetContainer.appendChild( g_InsetRenderer.domElement );
				g_InsetScene = new THREE.Scene();
				g_InsetCamera = new THREE.PerspectiveCamera( INSET_CAM_FOV, 
										INSET_CANVAS_WIDTH / INSET_CANVAS_HEIGHT, 
										INSET_CAM_NEAR, 
										INSET_CAM_FAR );
				g_InsetCamera.up = g_Camera.up;
        			g_InsetCamera.position.set(0, 0, -50);

				g_InsetScene.add( new THREE.AxisHelper( 50 ) );

				// TBD: dummy object to confirm I can process clicks ok in inset window
				var geo = new THREE.CubeGeometry( 10, 10, 10 );
				var material = new THREE.MeshNormalMaterial();
				g_ControlPanelObjectTest = new THREE.Mesh( geo, material );
				g_ControlPanelObjectTest.name = "dummyTBD";
				g_InsetScene.add( g_ControlPanelObjectTest );
			}

			function setupCollisionDetection()
			{
				g_Raycaster = new THREE.Raycaster();

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			}

			//
			// Game Loop
			//

			// gameLoop()
			// Standard game loop with a fixed update rate to keep
			// things consistent, and a variable render rate to allow
			// for differences in machine performance
			//
			function gameLoop()
			{
				var elapsedTime = g_Clock.getDelta();

				g_Lag += elapsedTime;

				// perform as many updates as we should do
				// based on the time elapsed from last gameloop call
				while( g_Lag >= UPDATE_TIME_STEP )
				{
					update();

					g_Lag -= UPDATE_TIME_STEP;
				}

				render();

				requestAnimationFrame(gameLoop);
			}

			function update()
			{
				// Note: The time elapsed is UPDATE_TIME_STEP as we update in fixed steps
				if( g_InsetEnabled )
				{
					g_InsetCamera.lookAt( g_InsetScene.position );
				}
			}

			function render( )
			{
				g_Renderer.render(g_Scene, g_Camera);
				if( g_InsetEnabled )
				{
					g_InsetRenderer.render(g_InsetScene, g_InsetCamera);
				}
			}

			function handleResize()
			{
				var width = g_Container.offsetWidth;
				var height = g_Container.offsetHeight;

				g_Camera.aspect = width / height;
			        g_Camera.updateProjectionMatrix();

				g_Renderer.setSize(width, height);
			}

			// Detect object clicks
			function onDocumentTouchStart( event )
			{
				event.preventDefault();
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );
			}

			function onDocumentMouseDown( event )
			{
				event.preventDefault();

				var mainElement = document.getElementById("AlgoMission");
				var mainWindowHeight = mainElement.clientHeight;

				// The event's X & Y are in relation to the main window
				// so we adjust them to be in relation to the inset window
				var insetClientX = event.clientX - (INSET_LEFT_OFFSET + INSET_MARGIN);
				var insetClientY = event.clientY - (mainWindowHeight - INSET_CANVAS_HEIGHT - (INSET_BOTTOM_OFFSET + INSET_MARGIN));

				// Normalise the X & Y and test for intersection with inset window objects
				var mouse = new THREE.Vector2();
 				mouse.x = ( insetClientX / g_InsetRenderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( insetClientY / g_InsetRenderer.domElement.clientHeight ) * 2 + 1;

				g_Raycaster.setFromCamera( mouse, g_InsetCamera );

				var buttonObjects = [];
				buttonObjects.push( g_ControlPanelObjectTest );

				var buttonIntersects = g_Raycaster.intersectObjects( buttonObjects );

				if( buttonIntersects.length > 0 )
				{
					// Intersection detected
					console.log( "object " + buttonIntersects[ 0 ].object.name + " clicked");
				}
			}

			//
			// Debugging Functions
			//

			function addAxisHelper()
			{
				g_Scene.add( new THREE.AxisHelper( 50 ) );
			}
		</script>
	</body>
</html>
